# Essential Operations
```c++
class X {
public:
    // constructor
    X(Sometype);            // ordinary constructor
    X();                    // default constructor
    X(const X&);            // copy constructor
    X(X&&);                 // move constructor
    // assignment
    X& operator=(const X&); // copy assignment
    X& operator=(X&&);      // move assignment
    // destructor
    ~X();
};
```

Except for the “ordinary constructor,” these special member functions will be generated by the compiler as needed. If you want to be explicit about generating `default` implementations, you can:

```c++
class Y {
public:
    Y(Sometype);
    // I really do want the default opy constructor
    Y(const Y&) = default;
    // and the default move constructor
    Y(Y&&) = default;
    // ...
};
```

If you are explicit about some defaults, other default definitions will not be generated.

A good rule of thumb (sometimes called *the rule of zero*) is to either define all of the essential operations or none (using the default for all).

To complement `=default`, we have `=delete` to indicate that an operation is not to be generated. A base class in a class hierarchy is the classical example where we don’t want to allow a memberwise copy. For example:

```c++
class Shape {
public:
    // no copy operations
    Shape(const Shape&) =delete;
    Shape& operator=(const Shape&) =delete;
    // ...
};

void copy(Shape& s1, const Shape& s2)
{
    s1 = s2;  // error: Shape copy is deleted
}
```

## Conversions

A constructor taking a single argument defines a conversion from its argument type.

```c++
complex z1 = 3.14;  // z1 becomes {3.14,0.0}

Vector v1(7);       // OK: v1 has 7 elements
Vector v2 = 7;      // OK: v2 has 7 elements
```

This is typically considered unfortunate, and the standard-library `vector` does not allow this int-to-vector “conversion.”

The way to avoid this problem is to say that only explicit “conversion” is allowed; that is, we can define the constructor like this:

```c++
class Vector {
public:
    // no implicit conversion from int to Vector
    explicit Vector(int s);
    // ...
};

Vector v1(7);   // OK: v1 has 7 elements

// error: no implicit conversion from int to Vector
Vector v2 = 7;
```

When it comes to conversions, more types are like Vector than are like complex, so use explicit for constructors that take a single argument unless there is a good reason not to.

## Member Initializers

When a data member of a class is defined, we can supply a default initializer called a *default member initializer*.

```c++
class complex {
    // representation: two doubles with default value 0.0
    double re = 0;
    double im = 0;
public:
    // construct complex from two scalars: {r,i}
    complex(double r, double i) :re{r}, im{i} {}
    // construct complex from one scalar: {r,0}
    complex(double r) :re{r} {}
    // default complex: {0,0}
    complex() {}
    // ...
};
```

This simplifies code and helps us to avoid accidentally leaving a member uninitialized.

# Copy and Move

By default, objects can be copied.
The default meaning of copy is memberwise copy: copy each member.

```c++
void test(complex z1)
{
    complex z2 {z1};    // copy initialization
    complex z3;
    z3 = z2;            // copy assignment
    // ...
}
```

For simple concrete types, memberwise copy is often exactly the right semantics for copy.

## Copying Containers

When a class is a resource handle – that is, when the class is responsible for an object accessed through a pointer – the default memberwise copy is typically a disaster.

A suitable definition of a copy constructor for Vector allocates the space for the required number of elements and then copies the elements into it so that after a copy each Vector has its own copy of the elements:

```c++
class Vector {
private:
    double* elem;
    int sz;
public:

    // copy constructor
    Vector(const Vector& a);

    // copy assignment
    Vector& operator=(const Vector& a);

};

Vector::Vector(const Vector& a)
  : elem{new double[a.sz]},
    sz{a.sz}
{
    for (int i=0; i!=sz; ++i)
        elem[i] = a.elem[i];
}

Vector& Vector::operator=(const Vector& a)
{
    double* p = new double[a.sz];
    for (int i=0; i!=a.sz; ++i)
        p[i] = a.elem[i];
    delete[] elem;         // delete old elements
    elem = p;
    sz = a.sz;
    return *this;
}
```

The name `this` is predefined in a member function and points to the object for which the member function is called.

## Moving Containers

```c++
Vector operator+(const Vector& a, const Vector& b)
{
    if (a.size()!=b.size())
        throw Vector_size_mismatch{};

    Vector res(a.size());
    for (int i=0; i!=a.size(); ++i)
        res[i]=a[i]+b[i];
    return res;
}
```

Returning from a `+` involves copying the result out of the local variable `res` and into some place where the caller can access it.

We didn’t really want a copy; we just wanted to get the result out of a function: we wanted to *move* a `Vector` rather than copy it. Fortunately, we can state that intent:

```c++
class Vector {
    // copy
    Vector(const Vector& a);             // constructor
    Vector& operator=(const Vector& a);  // assignment

    // move
    Vector(Vector&& a);                  // constructor
    Vector& operator=(Vector&& a);       // assignment
};

Vector::Vector(Vector&& a)
  : elem{a.elem},
    sz{a.sz}
{
    a.elem = nullptr;       // now a has no elements
    a.sz = 0;
}
```

The `&&` means “rvalue reference” and is a reference to which we can bind an rvalue. The word “rvalue” is intended to complement “lvalue,” which roughly means “something that can appear on the left-hand side of an assignment.” So an rvalue is – to a first approximation – a value that you can’t assign to, such as an integer returned by a function call. Thus, an rvalue reference is a reference to something that *nobody else* can assign to, so we can safely “steal” its value. The `res` local variable in `operator+()` for Vectors is an example.

> Klaus Iglberger, Back to Basics: Move Semantics (part 1 of 2), Cppcon 2019
>
> - Containers in C++ employ value semantics
> - In pre-C++11 this leads to unnecessary (exprensive) copy operations
> - C++11 introduces rvalue references to distinguish between lvalues and rvalues
> - rvalue referencces represent modifiable objects that are no longer needed

Where the programmer knows that a value will not be used again, but the compiler can’t be expected to be smart enough to figure that out, the programmer can be specific:

```c++
Vector f()
{
    Vector x(1000);
    Vector y(2000);
    Vector z(3000);
    z = x;              // we get a copy
    y = std::move(x);   // we get a move (move assignment)
     // ... better not use x here ...
    return z;           // we get a move
}
```

The standard-library function `move()` doesn’t actually move anything. Instead, it returns a reference to its argument from which we may move – an *rvalue reference*; it is a kind of cast.

When we return from `f()`, `z` is destroyed after its elements has been moved out of `f()` by the `return`. However, `y`’s destructor will `delete[]` its elements.

# Conventional Operations

Some operations have conventional meanings when defined for a type. These conventional meanings are often assumed by programmers and libraries (notably, the standard library), so it is wise to conform to them when designing new types for which the operations make sense.

- Comparisons: `==`, `!=`, `<`, `<=`, `>`, and `>=`
- Container operations: `size()`, `begin()`, and `end()`
- Input and output operations: `>>` and `<<`
- User-defined literals
- `swap()`
- Hash functions: `hash<>`

## Container Operations

The standard-library containers all know their number of elements and we can obtain it by calling `size()`.

```c++
// size_t is the name of the type returned by 
// a standard-library size()
for (size_t i = 0; i < c.size(); ++i)
    c[i] = 0;
```

However, rather than traversing containers using indices from 0 to `size()`, the standard algorithms (Chapter 12) rely on the notion of *sequences* delimited by pairs of *iterators*:

```c++
for (auto p = c.begin(); p != c.end(); ++p)
    *p = 0;
```

Here, `c.begin()` is an iterator pointing to the first element of c and `c.end()` points one-beyond-the-last element of c. Like pointers, iterators support `++` to move to the next element and `*` to access the value of the element pointed to. This *iterator model* (§12.3) allows for great generality and efficiency.

Another way of using the number of elements implicitly is a range-for loop:

```c++
for (auto& x : c)
    x = 0;
```

This uses `c.begin()` and `c.end()` implicitly and is roughly equivalent to the more explicit loop.

## User-Defined Literals

It can be useful to provide such literals for a user-defined type also. This is done by defining the meaning of a suitable suffix to a literal, so we can get

- `"Surprise!"s` is a `std::string`.
- `123s`` is `seconds`.
- `12.7i` is imaginary so that `12.7i + 47` is a complex number (i.e., {47, 12.7}).

Unsurprisingly, literals with user-defined suffixes are called *user-defined literals* or *UDLs*. Such literals are defined using *literal operators*.

```c++
constexpr complex<double> operator""i(long double arg)
{
    return {0, arg};
}
```

Here
- The `operator""` indicates that we are defining a literal operator.
- The `i` after the “literal indicator” `""` is the suffix to which the operator gives a meaning.
- The argument type, `long double`, indicates that the suffix (`i`) is being defined for a floating-point literal.
- The return type, `complex<double>`, specifies the type of the resulting literal.

## hash<>

The standard-library `unordered_map<K,V>` is a hash table with `K` as the key type and `V` as the value type (§11.5). To use a type `X` as a key, we must define `hash<X>`. The standard library does that for us for common types, such as `std::string`.

